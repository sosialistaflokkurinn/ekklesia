#!/bin/bash
# Pre-commit hook to prevent committing secrets
# Installation: cp git-hooks/pre-commit .git/hooks/pre-commit && chmod +x .git/hooks/pre-commit

set -e

# Set timeout for entire hook execution (5 seconds)
HOOK_TIMEOUT=5

# Function to run with timeout
run_with_timeout() {
  timeout $HOOK_TIMEOUT "$@"
  return $?
}

echo "üîç Running Ekklesia pre-commit checks (${HOOK_TIMEOUT}s timeout)..."

# --- 1. Check for political identity (existing check) ---
echo "üè¥ Checking political identity in staged files..."

# Get list of staged files
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM)

if [ -z "$STAGED_FILES" ]; then
  echo "‚úÖ No staged files to check"
  exit 0
fi

# Check for Icelandic political identity mentions
REQUIRED_PATTERNS=(
  "S√≥s√≠alistaflokk"
  "Socialist"
)

FOUND=false
for file in $STAGED_FILES; do
  if [ -f "$file" ]; then
    for pattern in "${REQUIRED_PATTERNS[@]}"; do
      if grep -qi "$pattern" "$file" 2>/dev/null; then
        FOUND=true
        break 2
      fi
    done
  fi
done

if [ "$FOUND" = false ]; then
  # Check if this is just a config/test file change
  if ! echo "$STAGED_FILES" | grep -qE '\.(json|ya?ml|txt|md)$'; then
    echo "‚ö†Ô∏è Warning: No political identity found in code files"
    echo "   This is OK for internal/infrastructure code"
  fi
fi

echo "‚úÖ Pre-commit checks passed"

# --- 2. Check for exposed secrets (NEW) ---
echo "üîê Scanning for exposed secrets..."

# Patterns that might indicate secrets
SECRET_PATTERNS=(
  # Database passwords
  'password.*=.*[A-Za-z0-9+/]{20,}'
  'PASSWORD.*=.*[A-Za-z0-9+/]{20,}'
  'PGPASSWORD.*=.*[A-Za-z0-9+/]{20,}'
  'DB_PASS.*=.*[A-Za-z0-9+/]{20,}'

  # API keys
  'api[_-]?key.*=.*[A-Za-z0-9+/]{20,}'
  'API[_-]?KEY.*=.*[A-Za-z0-9+/]{20,}'
  'secret[_-]?key.*=.*[A-Za-z0-9+/]{20,}'

  # GCP credentials
  'private_key.*BEGIN.*PRIVATE.*KEY'
  'credentials.*{.*private_key'

  # Generic secrets
  'token.*=.*[A-Za-z0-9+/]{32,}'
  'secret.*=.*[A-Za-z0-9+/]{32,}'

  # Connection strings with passwords
  'postgres://.*:[^@]*@'
  'mysql://.*:[^@]*@'
)

# PII patterns - These are checked in ALL files including .md
# Note: We use simple patterns then filter out known fake values
PII_PATTERNS=(
  # Icelandic kennitala (SSN) - CRITICAL PII
  # Format with hyphen: DDMMYY-NNNN
  '(0[1-9]|[12][0-9]|3[01])(0[1-9]|1[0-2])[0-9]{2}-[0-9]{4}'

  # Kennitala without hyphen: DDMMYYNNNN (10 digits)
  '\b[0-3][0-9][01][0-9][0-9]{6}\b'

  # Email addresses
  '\b[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}\b'

  # Icelandic phone numbers (7 digits, may have hyphen)
  # Format: NNN-NNNN or NNNNNNN
  '\b[2-9][0-9]{2}-?[0-9]{4}\b'

  # Firebase UID patterns (long alphanumeric strings)
  'uid.*=.*[a-zA-Z0-9]{25,}'
)

# Suspicious patterns that may contain real names (WARNING only, not blocking)
# These require manual review but won't block commit
SUSPICIOUS_NAME_PATTERNS=(
  # Icelandic surnames ending in -son, -sson, -d√≥ttir, -dottir
  # This catches most Icelandic names: J√≥nsson, Gunnarsson, Sigur√∞ard√≥ttir, etc.
  '\b[A-Z√Å√ê√â√ç√ì√ö√ù√û√Ü√ñ][a-z√°√∞√©√≠√≥√∫√Ω√æ√¶√∂]+(s{1,2}on|d[√≥o]ttir)\b'
  
  # Reporter: Real Name pattern (catches both Icelandic and foreign surnames)
  # Example: J√≥n Ferd√≠nand, PERSON_26
  '\*\*Reporter:\*\*.*[A-Z√Å√ê√â√ç√ì√ö√ù√û√Ü√ñ][a-z√°√∞√©√≠√≥√∫√Ω√æ√¶√∂]+\s+[A-Z√Å√ê√â√ç√ì√ö√ù√û√Ü√ñ][a-z√°√∞√©√≠√≥√∫√Ω√æ√¶√∂]+'
  
  # User: Real Name pattern
  '\*\*User:\*\*.*[A-Z√Å√ê√â√ç√ì√ö√ù√û√Ü√ñ][a-z√°√∞√©√≠√≥√∫√Ω√æ√¶√∂]+\s+[A-Z√Å√ê√â√ç√ì√ö√ù√û√Ü√ñ][a-z√°√∞√©√≠√≥√∫√Ω√æ√¶√∂]+'
  
  # Who: Real Name pattern
  '- \*\*Who:\*\*.*[A-Z√Å√ê√â√ç√ì√ö√ù√û√Ü√ñ][a-z√°√∞√©√≠√≥√∫√Ω√æ√¶√∂]+\s+[A-Z√Å√ê√â√ç√ì√ö√ù√û√Ü√ñ][a-z√°√∞√©√≠√≥√∫√Ω√æ√¶√∂]+'
  
  # Reviewer: Real Name pattern (at end of docs)
  '\*\*Reviewer:\*\*.*[A-Z√Å√ê√â√ç√ì√ö√ù√û√Ü√ñ][a-z√°√∞√©√≠√≥√∫√Ω√æ√¶√∂]+\s+[A-Z√Å√ê√â√ç√ì√ö√ù√û√Ü√ñ][a-z√°√∞√©√≠√≥√∫√Ω√æ√¶√∂]+'
)

# Known fake/example values to ALLOW (will be filtered out)
# Use obviously fake values that cannot be real data
FAKE_VALUES=(
  "000000-0000"  # Invalid kennitala (impossible date)
  "999999-9999"  # Invalid kennitala (impossible date)
  "9999999999"   # Invalid kennitala without hyphen
  "111111-1111"  # Clearly fake kennitala
  "123456-7890"  # Sequential fake kennitala
  "0101901234"   # Example without hyphen
  "example@example.com"
  "nafn@example.is"
  "old@example.com"
  "new@example.com"
  "new@email.is"
  "test@example.com"
  "test@example.is"
  "jon@example.com"
  "jon@example.is"
  "jon@test.is"
  "jon.jonsson@example.com"
  "newemail@example.is"
  "demo@example.com"
  "sample@example.com"
  "user@example.com"
  "your.email@example.com"
  "your@email.com"  # Generic placeholder in error messages
  "user.name@domain.co.uk"
  "copilot@github.com"  # GitHub Copilot co-authorship (blocked in commit-msg)
  "noreply@anthropic.com"  # Claude co-authorship (blocked in commit-msg)
  "gudrodur@sosialistaflokkurinn.is"
  "gudrodur@example.com"
  "real.person@gmail.com"
  "ekklesia-sync@ekklesia-prod-10-2025.iam.gserviceaccount.com"
  "521240388393-compute@developer.gserviceaccount.com"
  "555-0000"  # North American fake number pattern
  "555-0100"  # Reserved for fictional use
  "555-0199"  # Reserved range
  "555-1234"  # Common fake number
  "5551234"   # Common fake number without hyphen
  "999-9999"  # Clearly fake Icelandic pattern
  "9999999"   # Clearly fake without hyphen
  "000-0000"  # Clearly fake
  "0000000"   # Clearly fake without hyphen
  "775-8493"  # Example numbers from docs
  "7758493"   # Example numbers from docs
  "780-8189"  # Example numbers from docs
  "+1-555-0100"  # International fake format
  "+354-999-9999"  # Iceland fake with country code
  "+3545551234"  # Example international format
  "0035455551234"  # Example E.164 format
  "abc123XYZ789ExampleUserUID456"
)

# Files to exclude from secret scanning (but NOT PII scanning)
SECRET_EXCLUDE_PATTERNS=(
  '\.md$'          # Markdown documentation (may have example code)
  '\.txt$'         # Text files (may contain examples)
  'test.*\.py$'    # Test files
  'test.*\.js$'    # Test files
  '\.json$'        # JSON config (usually env var references)
  '\.ya?ml$'       # YAML config (usually env var references)
  'pre-commit$'    # Git hooks (contain regex patterns, not actual secrets)
  'package-lock'   # Dependency lock files
  'requirements'   # Python requirements
  'git-hooks/'     # Pre-commit hook itself (contains secret patterns for detection)
  '\.git/hooks/'   # Git hooks directory
  'pre-commit$'    # Pre-commit hook file
)

# Files to exclude from PII scanning (much more restricted)
PII_EXCLUDE_PATTERNS=(
  'test.*\.py$'    # Test files only
  'test.*\.js$'    # Test files only
  'package-lock'   # Dependency lock files
  'requirements'   # Python requirements
)

SECRETS_FOUND=false
PII_FOUND=false
SUSPICIOUS_NAMES_FOUND=false

# First pass: Check for secrets (excluding documentation)
for file in $STAGED_FILES; do
  # Skip files excluded from secret scanning
  SKIP=false
  for exclude in "${SECRET_EXCLUDE_PATTERNS[@]}"; do
    if echo "$file" | grep -qE "$exclude"; then
      SKIP=true
      break
    fi
  done

  if [ "$SKIP" = true ]; then
    continue
  fi

  # Check if file exists (might be deleted)
  if [ ! -f "$file" ]; then
    continue
  fi

  # Scan for secret patterns (with optimized grep)
  for pattern in "${SECRET_PATTERNS[@]}"; do
    # Use -m 1 to stop after first match (faster)
    # Use timeout to prevent hanging
    # Capture matches to check if any found before printing
    MATCHES=$(timeout 1 grep -EHn -m 1 "$pattern" "$file" 2>/dev/null || true)
    if [ -n "$MATCHES" ]; then
      SECRETS_FOUND=true
      echo ""
      echo "‚ö†Ô∏è Potential secret detected in: $file"
      echo "   Pattern: $pattern"
      echo "$MATCHES"
    fi
  done
done

# Second pass: Check for PII (including .md files!)
echo "üîí Scanning for PII (including documentation)..."

for file in $STAGED_FILES; do
  # Skip files excluded from PII scanning (only test files)
  SKIP=false
  for exclude in "${PII_EXCLUDE_PATTERNS[@]}"; do
    if echo "$file" | grep -qE "$exclude"; then
      SKIP=true
      break
    fi
  done

  if [ "$SKIP" = true ]; then
    continue
  fi

  # Check if file exists (might be deleted)
  if [ ! -f "$file" ]; then
    continue
  fi

  # Scan for PII patterns (with optimized grep)
  for pattern in "${PII_PATTERNS[@]}"; do
    # Use timeout to prevent hanging
    MATCHES=$(timeout 1 grep -EHn -m 10 "$pattern" "$file" 2>/dev/null || true)
    if [ -n "$MATCHES" ]; then
      # Filter out known fake values
      while IFS= read -r line; do
        IS_FAKE=false
        for fake in "${FAKE_VALUES[@]}"; do
          if echo "$line" | grep -qF "$fake"; then
            IS_FAKE=true
            break
          fi
        done

        if [ "$IS_FAKE" = false ]; then
          PII_FOUND=true
          echo ""
          echo "‚ö†Ô∏è POTENTIAL PII DETECTED in: $line"
        fi
      done <<< "$MATCHES"
    fi
  done
done

# Third pass: Check for suspicious name patterns in .md files (WARNING only)
echo "üë§ Checking for potential real names in documentation..."

for file in $STAGED_FILES; do
  # Only check .md files
  if ! echo "$file" | grep -qE '\.md$'; then
    continue
  fi

  # Check if file exists
  if [ ! -f "$file" ]; then
    continue
  fi

  # Scan for suspicious name patterns
  for pattern in "${SUSPICIOUS_NAME_PATTERNS[@]}"; do
    MATCHES=$(timeout 1 grep -EHn -m 5 "$pattern" "$file" 2>/dev/null || true)
    if [ -n "$MATCHES" ]; then
      # Check if it contains [REDACTED] - if so, it's already redacted
      if ! echo "$MATCHES" | grep -qF "[REDACTED]"; then
        SUSPICIOUS_NAMES_FOUND=true
        echo ""
        echo "‚ö†Ô∏è POTENTIAL REAL NAME in: $file"
        echo "$MATCHES"
      fi
    fi
  done
done

if [ "$SECRETS_FOUND" = true ] || [ "$PII_FOUND" = true ]; then
  echo ""
  echo "‚ùå Commit blocked: Potential secrets or PII detected!"
  echo ""
  echo "Please review the matched lines above."
  echo ""

  if [ "$PII_FOUND" = true ]; then
    echo "üîí PII DETECTED:"
    echo "  - Replace real kennitalas with fake examples (000000-0000, 111111-1111)"
    echo "  - Replace real emails with example@example.com"
    echo "  - Replace real phone numbers with 555-1234"
    echo "  - Replace real names with 'J√≥n J√≥nsson' or similar"
    echo "  - Replace real addresses with fictional ones"
    echo ""
  fi

  if [ "$SECRETS_FOUND" = true ]; then
    echo "üîê SECRETS DETECTED:"
    echo "  - Move to environment variables (Secret Manager)"
    echo "  - Use placeholder values in examples"
    echo "  - Document in comments why this is safe"
    echo ""
  fi

  echo "If you're SURE these are safe (test data, examples, etc.):"
  echo "  git commit --no-verify"
  echo ""
  echo "Related: Issue #48 (database password exposure incident)"
  exit 1
fi

# Show warning for suspicious names (but don't block)
if [ "$SUSPICIOUS_NAMES_FOUND" = true ]; then
  echo ""
  echo "‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è WARNING: POTENTIAL REAL NAMES DETECTED ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è"
  echo ""
  echo "Documentation files may contain real user names."
  echo "Please review and redact if these are real people:"
  echo ""
  echo "  - Use [REDACTED] for real names"
  echo "  - Use 'J√≥n J√≥nsson' or similar for examples"
  echo "  - Use [REDACTED - superuser] for role descriptions"
  echo ""
  echo "If you're confident these are test/example names, you can proceed."
  echo "Otherwise, please redact and re-commit."
  echo ""
  read -p "Continue with commit? (y/N): " -n 1 -r
  echo
  if [[ ! $REPLY =~ ^[Yy]$ ]]; then
    echo "‚ùå Commit cancelled. Please redact real names and try again."
    exit 1
  fi
  echo "‚úÖ Proceeding with commit (reviewer confirmed)"
fi

echo "‚úÖ No secrets or PII detected in staged files"

# --- 3. Check commit message for political identity ---
echo "üè¥ Checking commit message for political identity..."

# This check runs in commit-msg hook, but we can prepare for it
# (commit-msg hook will run after this pre-commit hook)

exit 0
