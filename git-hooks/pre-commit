#!/bin/bash
# Pre-commit hook to prevent committing secrets
# Installation: cp git-hooks/pre-commit .git/hooks/pre-commit && chmod +x .git/hooks/pre-commit

set -e

echo "üîç Running Ekklesia pre-commit checks..."

# --- 1. Check for political identity (existing check) ---
echo "üè¥ Checking political identity in staged files..."

# Get list of staged files
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM)

if [ -z "$STAGED_FILES" ]; then
  echo "‚úÖ No staged files to check"
  exit 0
fi

# Check for Icelandic political identity mentions
REQUIRED_PATTERNS=(
  "S√≥s√≠alistaflokk"
  "Socialist"
)

FOUND=false
for file in $STAGED_FILES; do
  if [ -f "$file" ]; then
    for pattern in "${REQUIRED_PATTERNS[@]}"; do
      if grep -qi "$pattern" "$file" 2>/dev/null; then
        FOUND=true
        break 2
      fi
    done
  fi
done

if [ "$FOUND" = false ]; then
  # Check if this is just a config/test file change
  if ! echo "$STAGED_FILES" | grep -qE '\.(json|ya?ml|txt|md)$'; then
    echo "‚ö†Ô∏è Warning: No political identity found in code files"
    echo "   This is OK for internal/infrastructure code"
  fi
fi

echo "‚úÖ Pre-commit checks passed"

# --- 2. Check for exposed secrets (NEW) ---
echo "üîê Scanning for exposed secrets..."

# Patterns that might indicate secrets
SECRET_PATTERNS=(
  # Database passwords
  'password.*=.*[A-Za-z0-9+/]{20,}'
  'PASSWORD.*=.*[A-Za-z0-9+/]{20,}'
  'PGPASSWORD.*=.*[A-Za-z0-9+/]{20,}'
  'DB_PASS.*=.*[A-Za-z0-9+/]{20,}'
  
  # API keys
  'api[_-]?key.*=.*[A-Za-z0-9+/]{20,}'
  'API[_-]?KEY.*=.*[A-Za-z0-9+/]{20,}'
  'secret[_-]?key.*=.*[A-Za-z0-9+/]{20,}'
  
  # GCP credentials
  'private_key.*BEGIN.*PRIVATE.*KEY'
  'credentials.*{.*private_key'
  
  # Generic secrets
  'token.*=.*[A-Za-z0-9+/]{32,}'
  'secret.*=.*[A-Za-z0-9+/]{32,}'
  
  # Connection strings with passwords
  'postgres://.*:[^@]*@'
  'mysql://.*:[^@]*@'

  # Icelandic kennitala (SSN) - CRITICAL PII
  # Format: DDMMYY-NNNN (e.g., 000000-0000)
  # Exclude our fake example kennitala: 000000-0000
  '(0[1-9]|[12][0-9]|3[01])(0[1-9]|1[0-2])[0-9]{2}-(?!2939)[0-9]{4}'

  # Firebase UID patterns (long alphanumeric strings)
  # Exclude our fake example: abc123XYZ789ExampleUserUID456
  'uid.*=.*[a-zA-Z0-9]{25,}(?!abc123XYZ789ExampleUserUID456)'
)

# Files to exclude from secret scanning
EXCLUDE_PATTERNS=(
  '\.md$'          # Markdown documentation
  '\.txt$'         # Text files (may contain examples)
  'test.*\.py$'    # Test files
  'test.*\.js$'    # Test files
  '\.json$'        # JSON config (usually env var references)
  '\.ya?ml$'       # YAML config (usually env var references)
  'package-lock'   # Dependency lock files
  'requirements'   # Python requirements
)

SECRETS_FOUND=false

for file in $STAGED_FILES; do
  # Skip excluded files
  SKIP=false
  for exclude in "${EXCLUDE_PATTERNS[@]}"; do
    if echo "$file" | grep -qE "$exclude"; then
      SKIP=true
      break
    fi
  done
  
  if [ "$SKIP" = true ]; then
    continue
  fi
  
  # Check if file exists (might be deleted)
  if [ ! -f "$file" ]; then
    continue
  fi
  
  # Scan for secret patterns
  for pattern in "${SECRET_PATTERNS[@]}"; do
    if grep -EHn "$pattern" "$file" 2>/dev/null; then
      SECRETS_FOUND=true
      echo ""
      echo "‚ö†Ô∏è Potential secret detected in: $file"
      echo "   Pattern: $pattern"
    fi
  done
done

if [ "$SECRETS_FOUND" = true ]; then
  echo ""
  echo "‚ùå Commit blocked: Potential secrets detected!"
  echo ""
  echo "Please review the matched lines above."
  echo ""
  echo "If these are NOT secrets:"
  echo "  - Move to environment variables (Secret Manager)"
  echo "  - Use placeholder values in examples"
  echo "  - Document in comments why this is safe"
  echo ""
  echo "If you're SURE these are safe:"
  echo "  git commit --no-verify"
  echo ""
  echo "Related: Issue #48 (database password exposure incident)"
  exit 1
fi

echo "‚úÖ No secrets detected in staged files"

# --- 3. Check for PII in documentation and templates (Issue #240) ---
echo "üîí Scanning for PII (including documentation)..."

# PII patterns (excluding fake examples)
KENNITALA_PATTERN='(0[1-9]|[12][0-9]|3[01])(0[1-9]|1[0-2])[0-9]{2}-?(?!0000|1111|2939)[0-9]{4}'
EMAIL_PATTERN='[A-Za-z0-9._%+-]+@(?!example\.com)[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}'
PHONE_PATTERN='[0-9]{3}[\s-]?[0-9]{4}(?!555-1234|000-0000)'

# Files that MUST be scanned for PII (even if they're .md)
TEMPLATE_FILES=(
  ".github/ISSUE_TEMPLATE"
  ".github/pull_request_template.md"
  "docs/"
)

PII_FOUND=false

# Scan templates and docs specifically for PII
for file in $STAGED_FILES; do
  # Check if file is a template or doc
  IS_TEMPLATE=false
  for template_path in "${TEMPLATE_FILES[@]}"; do
    if [[ "$file" == *"$template_path"* ]]; then
      IS_TEMPLATE=true
      break
    fi
  done

  if [ "$IS_TEMPLATE" = false ]; then
    continue
  fi

  # Check if file exists
  if [ ! -f "$file" ]; then
    continue
  fi

  # Scan for PII patterns
  if grep -EHn "$KENNITALA_PATTERN" "$file" 2>/dev/null; then
    PII_FOUND=true
    echo "‚ö†Ô∏è POTENTIAL PII DETECTED in: $file"
    echo "   Pattern: Kennitala (Icelandic SSN)"
  fi

  if grep -EHn "$EMAIL_PATTERN" "$file" 2>/dev/null; then
    PII_FOUND=true
    echo "‚ö†Ô∏è POTENTIAL PII DETECTED in: $file"
    echo "   Pattern: Email address (not @example.com)"
  fi

  if grep -EHn "$PHONE_PATTERN" "$file" 2>/dev/null | grep -v "555-1234\|000-0000"; then
    PII_FOUND=true
    echo "‚ö†Ô∏è POTENTIAL PII DETECTED in: $file"
    echo "   Pattern: Phone number (Icelandic format)"
  fi
done

if [ "$PII_FOUND" = true ]; then
  echo ""
  echo "‚ùå Commit blocked: Potential PII detected in documentation/templates!"
  echo ""
  echo "GitHub issues, PRs, and docs must use FAKE examples only:"
  echo "  ‚úÖ Names: 'J√≥n J√≥nsson', 'Anna J√≥nsd√≥ttir'"
  echo "  ‚úÖ Kennitalas: '010190-0000', '111111-1111'"
  echo "  ‚úÖ Emails: 'email@example.com', 'user@example.com'"
  echo "  ‚úÖ Phones: '555-1234', '000-0000'"
  echo "  ‚úÖ Addresses: 'D√¶misgata 1, 000 D√¶misb√¶r'"
  echo ""
  echo "If you're SURE these are fake examples:"
  echo "  git commit --no-verify"
  echo ""
  echo "Related: Issue #240 (PII prevention), Issue #136 (PII exposure incident)"
  exit 1
fi

echo "‚úÖ No PII detected in templates/docs"

# --- 4. Check for TODO management issues (NEW) ---
echo "üìù Checking TODO management..."

# Count new unchecked TODOs in staged files
NEW_TODOS=0
COMPLETED_TODOS=0
TODO_FILES=()

for file in $STAGED_FILES; do
  # Only check markdown and code files
  if ! echo "$file" | grep -qE '\.(md|py|js|ts|tsx|jsx|go|java|rb|php)$'; then
    continue
  fi

  # Check if file exists
  if [ ! -f "$file" ]; then
    continue
  fi

  # Count unchecked TODOs (- [ ] pattern or TODO: pattern)
  FILE_TODOS=$(grep -E '(-\s*\[\s*\]\s*TODO|TODO:|# TODO|// TODO)' "$file" 2>/dev/null | wc -l)

  # Count completed but not removed TODOs
  FILE_COMPLETED=$(grep -E '(-\s*\[x\]\s*TODO.*|TODO.*DONE|TODO.*COMPLETED|TODO.*FIXED)' "$file" 2>/dev/null | wc -l)

  if [ "$FILE_TODOS" -gt 0 ]; then
    NEW_TODOS=$((NEW_TODOS + FILE_TODOS))
    TODO_FILES+=("$file: $FILE_TODOS TODOs")
  fi

  if [ "$FILE_COMPLETED" -gt 0 ]; then
    COMPLETED_TODOS=$((COMPLETED_TODOS + FILE_COMPLETED))
    echo "‚ö†Ô∏è  Found $FILE_COMPLETED completed TODO(s) in: $file"
    echo "   Consider removing completed TODOs or archiving them"
  fi
done

# Warn if adding many new TODOs (>5)
if [ "$NEW_TODOS" -gt 5 ]; then
  echo ""
  echo "‚ö†Ô∏è  Warning: Adding $NEW_TODOS new TODOs in this commit"
  echo ""
  for todo_file in "${TODO_FILES[@]}"; do
    echo "   - $todo_file"
  done
  echo ""
  echo "   üí° TODO Best Practices:"
  echo "   - Keep TODOs focused and actionable"
  echo "   - Add GitHub Issue references for complex work"
  echo "   - Consider creating GitHub Issues instead (for >3 related TODOs)"
  echo "   - See: docs/standards/TODO_CLEANUP_STRATEGY.md"
  echo ""
  echo "   To proceed anyway: git commit (no --no-verify needed, this is a warning)"
  echo ""
fi

# Suggest removal of completed TODOs
if [ "$COMPLETED_TODOS" -gt 0 ]; then
  echo ""
  echo "‚ö†Ô∏è  Found $COMPLETED_TODOS completed TODO(s) that should be removed"
  echo ""
  echo "   üí° Cleanup Suggestions:"
  echo "   - Remove completed TODOs from code"
  echo "   - Archive significant work to docs/archive/"
  echo "   - Update related GitHub Issues if applicable"
  echo ""
  echo "   To proceed anyway: git commit (no --no-verify needed, this is a warning)"
  echo ""
fi

if [ "$NEW_TODOS" -le 5 ] && [ "$COMPLETED_TODOS" -eq 0 ]; then
  echo "‚úÖ TODO management check passed"
fi

# --- 5. Check commit message for political identity ---
echo "üè¥ Checking commit message for political identity..."

# This check runs in commit-msg hook, but we can prepare for it
# (commit-msg hook will run after this pre-commit hook)

# --- 6. Check i18n consistency (string loaders) ---
echo "üåç Checking i18n string loader consistency..."

I18N_ISSUES=0

# Find JS files that import string loaders but don't call .load()
for file in $STAGED_FILES; do
  if [[ "$file" == *.js ]] && [ -f "$file" ]; then
    # Check if file imports R from strings-loader (excluding comments)
    if grep -v "^\s*//" "$file" | grep -q "import.*{.*R.*}.*from.*strings-loader" 2>/dev/null; then
      # Check if file calls R.load() (excluding comments)
      if ! grep -v "^\s*//" "$file" | grep -q "R\.load\s*(" 2>/dev/null; then
        echo "‚ö†Ô∏è  $file imports R but doesn't call R.load()"
        ((I18N_ISSUES++))
      fi
    fi
    
    # Check if file imports superuserStrings (excluding comments)
    if grep -v "^\s*//" "$file" | grep -q "import.*superuserStrings" 2>/dev/null; then
      # Check if file calls superuserStrings.load() (excluding comments)
      if ! grep -v "^\s*//" "$file" | grep -q "superuserStrings\.load\s*(" 2>/dev/null; then
        echo "‚ö†Ô∏è  $file imports superuserStrings but doesn't call .load()"
        ((I18N_ISSUES++))
      fi
    fi
    
    # Same check for adminStrings
    if grep -v "^\s*//" "$file" | grep -q "import.*adminStrings" 2>/dev/null; then
      if ! grep -v "^\s*//" "$file" | grep -q "adminStrings\.load\s*(" 2>/dev/null; then
        echo "‚ö†Ô∏è  $file imports adminStrings but doesn't call .load()"
        ((I18N_ISSUES++))
      fi
    fi
    
    # Same check for electionsStrings
    if grep -v "^\s*//" "$file" | grep -q "import.*electionsStrings" 2>/dev/null; then
      if ! grep -v "^\s*//" "$file" | grep -q "electionsStrings\.load\s*(" 2>/dev/null; then
        echo "‚ö†Ô∏è  $file imports electionsStrings but doesn't call .load()"
        ((I18N_ISSUES++))
      fi
    fi
  fi
done

if [ "$I18N_ISSUES" -gt 0 ]; then
  echo ""
  echo "‚ùå Found $I18N_ISSUES i18n loader issue(s)"
  echo ""
  echo "   üí° Fix: Add 'await [loader].load();' in the init() function"
  echo "   Example:"
  echo "     async function init() {"
  echo "       await R.load('is');"
  echo "       await superuserStrings.load();  // <-- Add this"
  echo "       // ... rest of init"
  echo "     }"
  echo ""
  echo "   To bypass (not recommended): git commit --no-verify"
  exit 1
fi

echo "‚úÖ i18n consistency check passed"

# --- 7. Check for hardcoded Icelandic text (warning only) ---
echo "üáÆüá∏ Checking for hardcoded Icelandic text..."

# Only run if the script exists and there are HTML/JS files staged
if [ -f "scripts/utils/find-hardcoded-text.py" ]; then
  # Check if any HTML or JS files are staged
  if echo "$STAGED_FILES" | grep -qE '\.(html|js)$'; then
    # Run the check (warning only, don't block commit)
    HARDCODED_OUTPUT=$(python3 scripts/utils/find-hardcoded-text.py --staged 2>&1) || true
    HARDCODED_COUNT=$(echo "$HARDCODED_OUTPUT" | grep -o "Total hardcoded strings:.*" | grep -o "[0-9]*" | head -1)

    if [ -n "$HARDCODED_COUNT" ] && [ "$HARDCODED_COUNT" -gt 0 ]; then
      echo ""
      echo "‚ö†Ô∏è  Warning: Found $HARDCODED_COUNT hardcoded text string(s) in staged files"
      echo ""
      echo "   üí° Consider externalizing to XML string files:"
      echo "   - Run: python3 scripts/utils/find-hardcoded-text.py --staged --verbose"
      echo "   - See: docs/standards/I18N_ENFORCEMENT.md"
      echo ""
      echo "   (This is a warning only - commit will proceed)"
      echo ""
    else
      echo "‚úÖ No hardcoded text detected in staged files"
    fi
  fi
fi

# --- 8. Check naming conventions (warning only) ---
echo "üìù Checking naming conventions..."

# Only run if the script exists
if [ -f "scripts/analysis/analyze-naming.py" ]; then
  # Check if any JS or Python files are staged
  if echo "$STAGED_FILES" | grep -qE '\.(js|py)$'; then
    # Run the analyzer on staged files
    NAMING_OUTPUT=$(python3 scripts/analysis/analyze-naming.py 2>&1) || true
    NAMING_VIOLATIONS=$(echo "$NAMING_OUTPUT" | grep -c "VIOLATION" || true)
    NAMING_WARNINGS=$(echo "$NAMING_OUTPUT" | grep -c "‚ö†Ô∏è" || true)

    if [ "$NAMING_VIOLATIONS" -gt 0 ]; then
      echo ""
      echo "‚ö†Ô∏è  Warning: Found $NAMING_VIOLATIONS naming convention violation(s)"
      echo ""
      echo "   üí° Run for details: python3 scripts/analysis/analyze-naming.py"
      echo "   üìñ See: docs/standards/NAMING_CONVENTIONS.md"
      echo ""
      echo "   (This is a warning only - commit will proceed)"
      echo ""
    elif [ "$NAMING_WARNINGS" -gt 0 ]; then
      echo "‚ö†Ô∏è  Found $NAMING_WARNINGS naming convention warning(s) (run analyzer for details)"
    else
      echo "‚úÖ Naming conventions check passed"
    fi
  fi
fi

exit 0
