#!/bin/bash
# Pre-commit hook to prevent committing secrets
# Installation: cp git-hooks/pre-commit .git/hooks/pre-commit && chmod +x .git/hooks/pre-commit

set -e

echo "üîç Running Ekklesia pre-commit checks..."

# --- 1. Check for political identity (existing check) ---
echo "üè¥ Checking political identity in staged files..."

# Get list of staged files
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM)

if [ -z "$STAGED_FILES" ]; then
  echo "‚úÖ No staged files to check"
  exit 0
fi

# Check for Icelandic political identity mentions
REQUIRED_PATTERNS=(
  "S√≥s√≠alistaflokk"
  "Socialist"
)

FOUND=false
for file in $STAGED_FILES; do
  if [ -f "$file" ]; then
    for pattern in "${REQUIRED_PATTERNS[@]}"; do
      if grep -qi "$pattern" "$file" 2>/dev/null; then
        FOUND=true
        break 2
      fi
    done
  fi
done

if [ "$FOUND" = false ]; then
  # Check if this is just a config/test file change
  if ! echo "$STAGED_FILES" | grep -qE '\.(json|ya?ml|txt|md)$'; then
    echo "‚ö†Ô∏è Warning: No political identity found in code files"
    echo "   This is OK for internal/infrastructure code"
  fi
fi

echo "‚úÖ Pre-commit checks passed"

# --- 2. Check for exposed secrets (NEW) ---
echo "üîê Scanning for exposed secrets..."

# Patterns that might indicate secrets
SECRET_PATTERNS=(
  # Database passwords
  'password.*=.*[A-Za-z0-9+/]{20,}'
  'PASSWORD.*=.*[A-Za-z0-9+/]{20,}'
  'PGPASSWORD.*=.*[A-Za-z0-9+/]{20,}'
  'DB_PASS.*=.*[A-Za-z0-9+/]{20,}'
  
  # API keys
  'api[_-]?key.*=.*[A-Za-z0-9+/]{20,}'
  'API[_-]?KEY.*=.*[A-Za-z0-9+/]{20,}'
  'secret[_-]?key.*=.*[A-Za-z0-9+/]{20,}'
  
  # GCP credentials
  'private_key.*BEGIN.*PRIVATE.*KEY'
  'credentials.*{.*private_key'
  
  # Generic secrets
  'token.*=.*[A-Za-z0-9+/]{32,}'
  'secret.*=.*[A-Za-z0-9+/]{32,}'
  
  # Connection strings with passwords
  'postgres://.*:[^@]*@'
  'mysql://.*:[^@]*@'

  # Icelandic kennitala (SSN) - CRITICAL PII
  # Format: DDMMYY-NNNN (e.g., 000000-0000)
  # Exclude our fake example kennitala: 000000-0000
  '(0[1-9]|[12][0-9]|3[01])(0[1-9]|1[0-2])[0-9]{2}-(?!2939)[0-9]{4}'

  # Firebase UID patterns (long alphanumeric strings)
  # Exclude our fake example: abc123XYZ789ExampleUserUID456
  'uid.*=.*[a-zA-Z0-9]{25,}(?!abc123XYZ789ExampleUserUID456)'
)

# Files to exclude from secret scanning
EXCLUDE_PATTERNS=(
  '\.md$'          # Markdown documentation
  '\.txt$'         # Text files (may contain examples)
  'test.*\.py$'    # Test files
  'test.*\.js$'    # Test files
  '\.json$'        # JSON config (usually env var references)
  '\.ya?ml$'       # YAML config (usually env var references)
  'package-lock'   # Dependency lock files
  'requirements'   # Python requirements
  '^git-hooks/'    # Git hooks contain detection patterns, not secrets
)

SECRETS_FOUND=false

for file in $STAGED_FILES; do
  # Skip excluded files
  SKIP=false
  for exclude in "${EXCLUDE_PATTERNS[@]}"; do
    if echo "$file" | grep -qE "$exclude"; then
      SKIP=true
      break
    fi
  done
  
  if [ "$SKIP" = true ]; then
    continue
  fi
  
  # Check if file exists (might be deleted)
  if [ ! -f "$file" ]; then
    continue
  fi
  
  # Scan for secret patterns
  for pattern in "${SECRET_PATTERNS[@]}"; do
    if grep -EHn "$pattern" "$file" 2>/dev/null; then
      SECRETS_FOUND=true
      echo ""
      echo "‚ö†Ô∏è Potential secret detected in: $file"
      echo "   Pattern: $pattern"
    fi
  done
done

if [ "$SECRETS_FOUND" = true ]; then
  echo ""
  echo "‚ùå Commit blocked: Potential secrets detected!"
  echo ""
  echo "Please review the matched lines above."
  echo ""
  echo "If these are NOT secrets:"
  echo "  - Move to environment variables (Secret Manager)"
  echo "  - Use placeholder values in examples"
  echo "  - Document in comments why this is safe"
  echo ""
  echo "If you're SURE these are safe:"
  echo "  git commit --no-verify"
  echo ""
  echo "Related: Issue #48 (database password exposure incident)"
  exit 1
fi

echo "‚úÖ No secrets detected in staged files"

# --- 3. Check for PII in ALL staged files (Issue #240, #360) ---
echo "üîí Scanning for PII (including documentation)..."

# Kennitala pattern - matches DDMMYYNNNN or DDMMYY-NNNN
# Excludes fake examples: 0000, 1111, 2939 as last 4 digits
KENNITALA_PATTERN='(0[1-9]|[12][0-9]|3[01])(0[1-9]|1[0-2])[0-9]{2}-?(?!0000|1111|2939)[0-9]{4}'

# Files to SKIP for PII scanning (binary, generated, etc.)
PII_EXCLUDE_PATTERNS=(
  '\.png$|\.jpg$|\.gif$|\.ico$|\.woff'   # Binary files
  'package-lock\.json$'                   # Generated
  'node_modules/'                         # Dependencies
  '\.min\.js$|\.min\.css$'               # Minified
  'replace-fake-data\.sh$'               # PII cleanup tool (contains search patterns)
)

PII_FOUND=false

# Scan ALL staged source files for kennitalas
for file in $STAGED_FILES; do
  # Skip excluded files
  SKIP=false
  for exclude in "${PII_EXCLUDE_PATTERNS[@]}"; do
    if echo "$file" | grep -qE "$exclude"; then
      SKIP=true
      break
    fi
  done

  if [ "$SKIP" = true ]; then
    continue
  fi

  # Check if file exists
  if [ ! -f "$file" ]; then
    continue
  fi

  # Scan for kennitala patterns in source files
  # Look for 10-digit numbers that match kennitala format (DDMMYYNNNN)
  # Use grep -P for Perl regex (supports lookahead) or fallback to basic pattern
  if command -v grep >/dev/null && grep -P "" /dev/null 2>/dev/null; then
    # Perl regex available - use lookahead to exclude fake kennitalas
    MATCHES=$(grep -PHn "$KENNITALA_PATTERN" "$file" 2>/dev/null | grep -v "000000-\?0000\|111111-\?1111\|010190-\?2939" || true)
  else
    # Fallback: basic pattern, filter fake ones with second grep
    MATCHES=$(grep -EHn "(0[1-9]|[12][0-9]|3[01])(0[1-9]|1[0-2])[0-9]{2}-?[0-9]{4}" "$file" 2>/dev/null | grep -v "000000-\?0000\|111111-\?1111\|010190-\?2939" || true)
  fi

  if [ -n "$MATCHES" ]; then
    PII_FOUND=true
    echo ""
    echo "‚ö†Ô∏è KENNITALA DETECTED in: $file"
    echo "   This appears to be a real Icelandic national ID (kennitala)"
    echo "$MATCHES" | head -5
  fi
done

if [ "$PII_FOUND" = true ]; then
  echo ""
  echo "‚ùå BLOCKED: Kennitala (Icelandic national ID) detected in code!"
  echo ""
  echo "Real kennitalas must NEVER be committed to the repository."
  echo ""
  echo "Options:"
  echo "  1. Load kennitalas from external file (add to .gitignore)"
  echo "  2. Use fake examples: '010190-2939', '111111-1111', '000000-0000'"
  echo "  3. Query from database at runtime"
  echo ""
  echo "If you're SURE these are fake examples:"
  echo "  git commit --no-verify"
  echo ""
  echo "Related: Issue #240, #360 (PII prevention)"
  exit 1
fi

echo "‚úÖ No PII detected in staged files"

# --- 4. Check for TODO management issues (NEW) ---
echo "üìù Checking TODO management..."

# Count new unchecked TODOs in staged files
NEW_TODOS=0
COMPLETED_TODOS=0
TODO_FILES=()

for file in $STAGED_FILES; do
  # Only check markdown and code files
  if ! echo "$file" | grep -qE '\.(md|py|js|ts|tsx|jsx|go|java|rb|php)$'; then
    continue
  fi

  # Check if file exists
  if [ ! -f "$file" ]; then
    continue
  fi

  # Count unchecked TODOs (- [ ] pattern or TODO: pattern)
  FILE_TODOS=$(grep -E '(-\s*\[\s*\]\s*TODO|TODO:|# TODO|// TODO)' "$file" 2>/dev/null | wc -l)

  # Count completed but not removed TODOs
  FILE_COMPLETED=$(grep -E '(-\s*\[x\]\s*TODO.*|TODO.*DONE|TODO.*COMPLETED|TODO.*FIXED)' "$file" 2>/dev/null | wc -l)

  if [ "$FILE_TODOS" -gt 0 ]; then
    NEW_TODOS=$((NEW_TODOS + FILE_TODOS))
    TODO_FILES+=("$file: $FILE_TODOS TODOs")
  fi

  if [ "$FILE_COMPLETED" -gt 0 ]; then
    COMPLETED_TODOS=$((COMPLETED_TODOS + FILE_COMPLETED))
    echo "‚ö†Ô∏è  Found $FILE_COMPLETED completed TODO(s) in: $file"
    echo "   Consider removing completed TODOs or archiving them"
  fi
done

# Warn if adding many new TODOs (>5)
if [ "$NEW_TODOS" -gt 5 ]; then
  echo ""
  echo "‚ö†Ô∏è  Warning: Adding $NEW_TODOS new TODOs in this commit"
  echo ""
  for todo_file in "${TODO_FILES[@]}"; do
    echo "   - $todo_file"
  done
  echo ""
  echo "   üí° TODO Best Practices:"
  echo "   - Keep TODOs focused and actionable"
  echo "   - Add GitHub Issue references for complex work"
  echo "   - Consider creating GitHub Issues instead (for >3 related TODOs)"
  echo "   - See: docs/PATTERNS.md"
  echo ""
  echo "   To proceed anyway: git commit (no --no-verify needed, this is a warning)"
  echo ""
fi

# Suggest removal of completed TODOs
if [ "$COMPLETED_TODOS" -gt 0 ]; then
  echo ""
  echo "‚ö†Ô∏è  Found $COMPLETED_TODOS completed TODO(s) that should be removed"
  echo ""
  echo "   üí° Cleanup Suggestions:"
  echo "   - Remove completed TODOs from code"
  echo "   - Archive significant work to docs/archive/"
  echo "   - Update related GitHub Issues if applicable"
  echo ""
  echo "   To proceed anyway: git commit (no --no-verify needed, this is a warning)"
  echo ""
fi

if [ "$NEW_TODOS" -le 5 ] && [ "$COMPLETED_TODOS" -eq 0 ]; then
  echo "‚úÖ TODO management check passed"
fi

# --- 5. Check commit message for political identity ---
echo "üè¥ Checking commit message for political identity..."

# This check runs in commit-msg hook, but we can prepare for it
# (commit-msg hook will run after this pre-commit hook)

# --- 6. Check i18n consistency (string loaders) ---
echo "üåç Checking i18n string loader consistency..."

I18N_ISSUES=0

# i18n Architecture:
# - Entry points (HTML loads directly): MUST call R.load() or delegate to initAuthenticatedPage()
# - Modules (imported by entry points): MAY use R.string without calling R.load()
#
# Entry point detection:
# - Files in apps/*/js/*.js are potential entry points
# - Files that call initAuthenticatedPage() or initI18n() are covered
# - Files in subdirectories (api/, components/, profile/, utils/) are modules
# - Library files (rbac.js, auth.js) in js/ root are also modules
#
# This check only validates entry points, not modules.

# Library modules in js/ root that are NOT entry points (imported by others)
JS_LIBRARY_MODULES="rbac.js|auth.js|page-init.js|nav-interactions.js"

for file in $STAGED_FILES; do
  if [[ "$file" == *.js ]] && [ -f "$file" ]; then
    # Skip module files - they're imported by entry points that handle R.load()
    # Module directories: api/, components/, profile/, utils/, services/, i18n/
    if [[ "$file" == */api/* ]] || \
       [[ "$file" == */components/* ]] || \
       [[ "$file" == */profile/* ]] || \
       [[ "$file" == */utils/* ]] || \
       [[ "$file" == */services/* ]] || \
       [[ "$file" == */i18n/* ]]; then
      continue
    fi
    
    # Skip library modules in js/ root (they're imported, not entry points)
    filename=$(basename "$file")
    if echo "$filename" | grep -qE "^($JS_LIBRARY_MODULES)$"; then
      continue
    fi
    
    # Check if file imports R from strings-loader (excluding comments)
    if grep -v "^\s*//" "$file" | grep -q "import.*{.*R.*}.*from.*strings-loader" 2>/dev/null; then
      # Entry point must either:
      # 1. Call R.load() directly, OR
      # 2. Call initAuthenticatedPage() which handles i18n, OR
      # 3. Call initI18n() which handles i18n
      if ! grep -v "^\s*//" "$file" | grep -qE "(R\.load\s*\(|initAuthenticatedPage\s*\(|initI18n\s*\()" 2>/dev/null; then
        echo "‚ö†Ô∏è  $file imports R but doesn't initialize i18n (R.load/initAuthenticatedPage/initI18n)"
        ((I18N_ISSUES++))
      fi
    fi
    
    # Check if file imports superuserStrings (excluding comments)
    if grep -v "^\s*//" "$file" | grep -q "import.*superuserStrings" 2>/dev/null; then
      # Check if file calls superuserStrings.load() (excluding comments)
      if ! grep -v "^\s*//" "$file" | grep -q "superuserStrings\.load\s*(" 2>/dev/null; then
        echo "‚ö†Ô∏è  $file imports superuserStrings but doesn't call .load()"
        ((I18N_ISSUES++))
      fi
    fi
    
    # Same check for adminStrings
    if grep -v "^\s*//" "$file" | grep -q "import.*adminStrings" 2>/dev/null; then
      if ! grep -v "^\s*//" "$file" | grep -q "adminStrings\.load\s*(" 2>/dev/null; then
        echo "‚ö†Ô∏è  $file imports adminStrings but doesn't call .load()"
        ((I18N_ISSUES++))
      fi
    fi
    
    # Same check for electionsStrings
    if grep -v "^\s*//" "$file" | grep -q "import.*electionsStrings" 2>/dev/null; then
      if ! grep -v "^\s*//" "$file" | grep -q "electionsStrings\.load\s*(" 2>/dev/null; then
        echo "‚ö†Ô∏è  $file imports electionsStrings but doesn't call .load()"
        ((I18N_ISSUES++))
      fi
    fi
  fi
done

if [ "$I18N_ISSUES" -gt 0 ]; then
  echo ""
  echo "‚ùå Found $I18N_ISSUES i18n loader issue(s)"
  echo ""
  echo "   üí° Fix: Add 'await [loader].load();' in the init() function"
  echo "   Example:"
  echo "     async function init() {"
  echo "       await R.load('is');"
  echo "       await superuserStrings.load();  // <-- Add this"
  echo "       // ... rest of init"
  echo "     }"
  echo ""
  echo "   To bypass (not recommended): git commit --no-verify"
  exit 1
fi

echo "‚úÖ i18n consistency check passed"

# --- 7. Check for hardcoded Icelandic text (warning only) ---
echo "üáÆüá∏ Checking for hardcoded Icelandic text..."

# Only run if the script exists and there are HTML/JS files staged
if [ -f "scripts/utils/find-hardcoded-text.py" ]; then
  # Check if any HTML or JS files are staged
  if echo "$STAGED_FILES" | grep -qE '\.(html|js)$'; then
    # Run the check (warning only, don't block commit)
    HARDCODED_OUTPUT=$(python3 scripts/utils/find-hardcoded-text.py --staged 2>&1) || true
    HARDCODED_COUNT=$(echo "$HARDCODED_OUTPUT" | grep -o "Total hardcoded strings:.*" | grep -o "[0-9]*" | head -1)

    if [ -n "$HARDCODED_COUNT" ] && [ "$HARDCODED_COUNT" -gt 0 ]; then
      echo ""
      echo "‚ö†Ô∏è  Warning: Found $HARDCODED_COUNT hardcoded text string(s) in staged files"
      echo ""
      echo "   üí° Consider externalizing to XML string files:"
      echo "   - Run: python3 scripts/utils/find-hardcoded-text.py --staged --verbose"
      echo "   - See: docs/PATTERNS.md (i18n Pattern section)"
      echo ""
      echo "   (This is a warning only - commit will proceed)"
      echo ""
    else
      echo "‚úÖ No hardcoded text detected in staged files"
    fi
  fi
fi

# --- 8. Check naming conventions (warning only) ---
echo "üìù Checking naming conventions..."

# Only run if the script exists
if [ -f "scripts/analysis/analyze-naming.py" ]; then
  # Check if any JS or Python files are staged
  if echo "$STAGED_FILES" | grep -qE '\.(js|py)$'; then
    # Run the analyzer on staged files
    NAMING_OUTPUT=$(python3 scripts/analysis/analyze-naming.py 2>&1) || true
    NAMING_VIOLATIONS=$(echo "$NAMING_OUTPUT" | grep -c "VIOLATION" || true)
    NAMING_WARNINGS=$(echo "$NAMING_OUTPUT" | grep -c "‚ö†Ô∏è" || true)

    if [ "$NAMING_VIOLATIONS" -gt 0 ]; then
      echo ""
      echo "‚ö†Ô∏è  Warning: Found $NAMING_VIOLATIONS naming convention violation(s)"
      echo ""
      echo "   üí° Run for details: python3 scripts/analysis/analyze-naming.py"
      echo "   üìñ See: docs/PATTERNS.md (File Naming section)"
      echo ""
      echo "   (This is a warning only - commit will proceed)"
      echo ""
    elif [ "$NAMING_WARNINGS" -gt 0 ]; then
      echo "‚ö†Ô∏è  Found $NAMING_WARNINGS naming convention warning(s) (run analyzer for details)"
    else
      echo "‚úÖ Naming conventions check passed"
    fi
  fi
fi

# --- 9. Check if CSS bundle needs rebuilding ---
echo "üé® Checking CSS bundle..."

# CSS files that are bundled (relative to repo root)
BUNDLED_CSS_FILES=(
  "apps/members-portal/styles/global.css"
  "apps/members-portal/styles/components/nav.css"
  "apps/members-portal/styles/components/page.css"
  "apps/members-portal/styles/components/button.css"
  "apps/members-portal/styles/components/badge.css"
  "apps/members-portal/styles/components/modal.css"
  "apps/members-portal/styles/components/toast.css"
  "apps/members-portal/styles/components/form.css"
)

CSS_CHANGED=false
for css_file in "${BUNDLED_CSS_FILES[@]}"; do
  if echo "$STAGED_FILES" | grep -q "^$css_file$"; then
    CSS_CHANGED=true
    break
  fi
done

if [ "$CSS_CHANGED" = true ]; then
  # Check if bundle.css is also staged
  if echo "$STAGED_FILES" | grep -q "apps/members-portal/styles/bundle.css"; then
    echo "‚úÖ CSS bundle is included in commit"
  else
    echo ""
    echo "‚ö†Ô∏è  CSS source files changed but bundle.css is NOT staged!"
    echo ""
    echo "   You modified bundled CSS files but forgot to rebuild bundle.css."
    echo ""
    echo "   üí° Run: ./scripts/build-css-bundle.sh"
    echo "   Then: git add apps/members-portal/styles/bundle.css"
    echo ""
    echo "   To skip this check (not recommended):"
    echo "   git commit --no-verify"
    echo ""
    exit 1
  fi
else
  echo "‚úÖ No bundled CSS files changed"
fi

# --- 10. Check for AI-generated authorship markers ---
echo "ü§ñ Checking for AI-generated authorship markers..."

AI_MARKERS_FOUND=false

for file in $STAGED_FILES; do
  if [ ! -f "$file" ]; then
    continue
  fi

  # Skip git-hooks/ - they contain detection patterns, not actual AI markers
  if [[ "$file" == git-hooks/* ]]; then
    continue
  fi

  # Check for Co-Authored-By with AI names
  if grep -qE "Co-Authored-By:.*Claude|Co-Authored-By:.*GPT|Co-Authored-By:.*Anthropic|Co-Authored-By:.*OpenAI" "$file" 2>/dev/null; then
    echo "‚ö†Ô∏è  AI authorship marker found in: $file"
    AI_MARKERS_FOUND=true
  fi

  # Check for "Generated with Claude Code" in code files
  if echo "$file" | grep -qE '\.(js|py|ts|tsx)$'; then
    if grep -q "Generated with.*Claude" "$file" 2>/dev/null; then
      echo "‚ö†Ô∏è  AI generation marker found in: $file"
      AI_MARKERS_FOUND=true
    fi
  fi
done

if [ "$AI_MARKERS_FOUND" = true ]; then
  echo ""
  echo "‚ùå Commit blocked: AI authorship markers detected in code files!"
  echo ""
  echo "   Remove these markers from code files."
  echo "   AI markers are OK in commit messages but NOT in source code."
  echo ""
  echo "   To bypass: git commit --no-verify"
  exit 1
fi

echo "‚úÖ AI authorship check passed"

# --- 11. Check for debug() misuse (PATTERNS.md) ---
echo "üêõ Checking for debug() misuse..."

DEBUG_ISSUES=0

for file in $STAGED_FILES; do
  if [[ "$file" == *.js ]] && [ -f "$file" ]; then
    # Check for debug( without .log/.warn/.error - common mistake
    # The pattern looks for debug('...' or debug("...' which is wrong usage
    # Exclude: debug.log(), debug.error(), logger.debug(), etc.
    DEBUG_RESULT=$(grep -En "debug\s*\(['\"]" "$file" 2>/dev/null | grep -Ev "(debug\.(log|warn|error|info)|\.debug\()" | head -5)
    if [ -n "$DEBUG_RESULT" ]; then
      echo "$DEBUG_RESULT"
      echo "‚ö†Ô∏è  Found debug() misuse in: $file"
      echo "   Use debug.log(), debug.warn(), or debug.error() instead"
      ((DEBUG_ISSUES++)) || true
    fi
  fi
done

if [ "$DEBUG_ISSUES" -gt 0 ]; then
  echo ""
  echo "‚ùå Found $DEBUG_ISSUES file(s) with debug() misuse"
  echo ""
  echo "   üí° Fix: debug is an object, not a function"
  echo "   ‚ùå debug('module', 'message')  // WRONG"
  echo "   ‚úÖ debug.log('module', 'message')  // CORRECT"
  echo ""
  echo "   See: docs/PATTERNS.md (Debug utility section)"
  echo ""
  echo "   To bypass: git commit --no-verify"
  exit 1
fi

echo "‚úÖ debug() usage check passed"

# --- 12. Check for toLocaleDateString('is-IS') usage (PATTERNS.md) ---
echo "üìÖ Checking for browser locale date formatting..."

LOCALE_ISSUES=0

for file in $STAGED_FILES; do
  if [[ "$file" == *.js ]] && [ -f "$file" ]; then
    # Check for toLocaleDateString or toLocaleTimeString with is-IS
    if grep -En "toLocale(Date|Time)String\s*\(\s*['\"]is" "$file" 2>/dev/null; then
      echo "‚ö†Ô∏è  Browser locale formatting in: $file"
      ((LOCALE_ISSUES++)) || true
    fi
  fi
done

if [ "$LOCALE_ISSUES" -gt 0 ]; then
  echo ""
  echo "‚ùå Found $LOCALE_ISSUES file(s) using browser locale formatting"
  echo ""
  echo "   üí° Browser support for 'is-IS' locale is inconsistent!"
  echo "   Use central formatters from util-format.js instead:"
  echo ""
  echo "   ‚ùå date.toLocaleDateString('is-IS')  // WRONG"
  echo "   ‚úÖ formatDateIcelandic(date)         // CORRECT"
  echo "   ‚úÖ formatDateOnlyIcelandic(date)     // CORRECT"
  echo ""
  echo "   See: docs/PATTERNS.md (Icelandic date formatters)"
  echo ""
  echo "   To bypass: git commit --no-verify"
  exit 1
fi

echo "‚úÖ Date formatting check passed"

# --- 13. Check for direct Firebase SDK imports (PATTERNS.md) ---
echo "üî• Checking for direct Firebase imports..."

FIREBASE_ISSUES=0

for file in $STAGED_FILES; do
  if [[ "$file" == *.js ]] && [ -f "$file" ]; then
    # Skip the firebase wrapper itself
    if [[ "$file" == *"/firebase/app.js" ]]; then
      continue
    fi

    # Check for direct gstatic.com imports
    if grep -En "from\s*['\"]https://www\.gstatic\.com/firebasejs" "$file" 2>/dev/null; then
      echo "‚ö†Ô∏è  Direct Firebase import in: $file"
      ((FIREBASE_ISSUES++)) || true
    fi
  fi
done

if [ "$FIREBASE_ISSUES" -gt 0 ]; then
  echo ""
  echo "‚ùå Found $FIREBASE_ISSUES file(s) with direct Firebase imports"
  echo ""
  echo "   üí° Use the wrapper instead of direct CDN imports:"
  echo ""
  echo "   ‚ùå import { ... } from 'https://www.gstatic.com/firebasejs/...'  // WRONG"
  echo "   ‚úÖ import { ... } from '/firebase/app.js'                        // CORRECT"
  echo ""
  echo "   See: docs/PATTERNS.md (Firebase Pattern)"
  echo ""
  echo "   To bypass: git commit --no-verify"
  exit 1
fi

echo "‚úÖ Firebase import check passed"

# --- 14. Check for localStorage in admin/superuser (PII security) ---
echo "üîê Checking for localStorage usage in admin areas..."

STORAGE_ISSUES=0

for file in $STAGED_FILES; do
  if [[ "$file" == *.js ]] && [ -f "$file" ]; then
    # Only check admin and superuser files
    if [[ "$file" == */admin/* ]] || [[ "$file" == */superuser/* ]]; then
      # Check for localStorage usage (should use sessionStorage for PII)
      if grep -En "localStorage\.(set|get)Item" "$file" 2>/dev/null; then
        echo "‚ö†Ô∏è  localStorage usage in admin/superuser file: $file"
        ((STORAGE_ISSUES++)) || true
      fi
    fi
  fi
done

if [ "$STORAGE_ISSUES" -gt 0 ]; then
  echo ""
  echo "‚ö†Ô∏è  Found $STORAGE_ISSUES admin/superuser file(s) using localStorage"
  echo ""
  echo "   üí° Admin areas handle PII - use sessionStorage instead:"
  echo ""
  echo "   ‚ùå localStorage.setItem('cache', data)   // PII persists indefinitely"
  echo "   ‚úÖ sessionStorage.setItem('cache', data) // Cleared on browser close"
  echo ""
  echo "   See: docs/PATTERNS.md (Client-Side Caching - PII Security)"
  echo ""
  echo "   (This is a warning only - commit will proceed)"
  echo ""
fi

# --- 15. Check for innerHTML without escapeHTML (XSS) ---
echo "üõ°Ô∏è Checking for potential XSS vulnerabilities..."

XSS_ISSUES=0

for file in $STAGED_FILES; do
  if [[ "$file" == *.js ]] && [ -f "$file" ]; then
    # Check for innerHTML with template literals containing variables
    # Pattern: innerHTML = `...${...}...` without escapeHTML
    if grep -En 'innerHTML\s*=\s*`[^`]*\$\{(?!.*escapeHTML)' "$file" 2>/dev/null; then
      # Double check - look for escapeHTML usage in the same file
      if ! grep -q "escapeHTML" "$file" 2>/dev/null; then
        echo "‚ö†Ô∏è  innerHTML with template literal (no escapeHTML) in: $file"
        ((XSS_ISSUES++)) || true
      fi
    fi
  fi
done

if [ "$XSS_ISSUES" -gt 0 ]; then
  echo ""
  echo "‚ö†Ô∏è  Found $XSS_ISSUES file(s) with potential XSS vulnerabilities"
  echo ""
  echo "   üí° When using innerHTML with user data, escape it:"
  echo ""
  echo "   ‚ùå el.innerHTML = \`<div>\${userData}</div>\`        // XSS risk"
  echo "   ‚úÖ el.innerHTML = \`<div>\${escapeHTML(userData)}</div>\`  // Safe"
  echo "   ‚úÖ el.textContent = userData                        // Also safe"
  echo ""
  echo "   See: docs/PATTERNS.md (XSS Prevention)"
  echo ""
  echo "   (This is a warning only - commit will proceed)"
  echo ""
fi

# --- 16. Check for custom auth rejection patterns (PATTERNS.md) ---
echo "üîë Checking for custom auth patterns..."

AUTH_ISSUES=0

for file in $STAGED_FILES; do
  if [[ "$file" == *.js ]] && [ -f "$file" ]; then
    # Skip the auth module itself (where requireAuth is DEFINED)
    if [[ "$file" == */session/auth.js ]]; then
      continue
    fi

    # Check for reject(new Error patterns related to login
    if grep -En "reject\s*\(\s*new\s+Error\s*\(\s*['\"].*([Nn]ot logged|[Nn]ot authenticated|[Nn]o user)" "$file" 2>/dev/null; then
      echo "‚ö†Ô∏è  Custom auth rejection in: $file"
      ((AUTH_ISSUES++)) || true
    fi
  fi
done

if [ "$AUTH_ISSUES" -gt 0 ]; then
  echo ""
  echo "‚ö†Ô∏è  Found $AUTH_ISSUES file(s) with custom auth rejection patterns"
  echo ""
  echo "   üí° Use requireAuth() instead of custom auth checks:"
  echo ""
  echo "   ‚ùå reject(new Error('Not logged in'))  // Shows error to user"
  echo "   ‚úÖ await requireAuth()                  // Redirects to login"
  echo ""
  echo "   See: docs/PATTERNS.md (Auth Guard Pattern)"
  echo ""
  echo "   (This is a warning only - commit will proceed)"
  echo ""
fi

# --- Final summary ---
echo ""
echo "üè¥ Checking commit message for political identity..."
echo "‚úÖ Commit message political identity check passed"

exit 0
